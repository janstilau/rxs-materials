import Foundation
import PromiseKit

// 通过, 将网络请求接口, 抽象成为业务参数和返回数据, 使得网络请求这件事, 也变为了协议.

/*
 这种, 代码组织的方式非常好.
 独立的业务, 具有独立的 API Protocol.
 然后 Fake 的实现, 和 API Protocol 的定义是放到一起的.
 在真正使用的时候, 其实可以将 Fake 的生成, 直接写到 VC 的内部, 目前这种, 根据编译条件进行生成的写法, 其实在真实开发中, 很少进行使用. 不过, 应该尝试一下.
 FakeRemoteAPI, 不在项目里面使用, 也是没有问题的. 因为本身就是开发的时候的过渡产品.
 
 这个时候, 突然就明白了, 书中所说的 Create On Demand 和 使用工厂类进行 Create 的区别了.
 使用工厂类进行创建, 工厂类所暴露出来的, create 返回的都是 Protocol 对象, 外界依赖工厂类进行各种 Protocol 对象的生成, 其实是将所有的逻辑进行了统一.
 我们假设, AuthRemoteAPI 要在各个地方进行使用, 那么在这些地方, 都写 FakeRemoteAPI() 的生成, 其实 CreateOnDemand 的处理方式.
 书里面, 将各个所需要的工具类, 都使用依赖注入的方式进行传入, 会让类难以使用, 因为需要做很多的配置工作, 这个时候, 直接将生成工具类的写到类里面, 其实是比较方便的.
 但是, 直接将生成动作, 写到了里面, 那么这层抽象还有个屁作用, 类直接依赖了对应的工具类, 而不是工具类的抽象.
 而且, 还有上面逻辑所说的重复代码, 难以快速理解的问题. 工厂类就是来做这个的.
 1. 避免重复代码的使用, 将所有的逻辑, 都集中都一点.
 2. 避免了创建细节的暴露, 工厂类里面到底创建出什么对象出来, 是工厂类的内部逻辑, 工厂类仅仅暴露出了, Create 抽象接口对象的 API.
 
 从这个意义上来说, 有这样的一个工厂类是很有必要的.
 那这样的话, 就是所有的对象, 依赖工厂类, 工厂类是单例, 或者 static 方法的集合.
 工厂类依赖所有的内部实际对象. 所有的内部实现对象, 仅仅在工厂类中被创建, 其他所有的对象, 是依赖接口, 在进行编程. 
 */
public protocol AuthRemoteAPI {
    
    func signIn(username: String, password: String) -> Promise<UserSession>
    func signUp(account: NewAccount) -> Promise<UserSession>
}
